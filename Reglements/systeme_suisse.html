<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.433">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Système suisse</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="systeme_suisse_files/libs/clipboard/clipboard.min.js"></script>
<script src="systeme_suisse_files/libs/quarto-html/quarto.js"></script>
<script src="systeme_suisse_files/libs/quarto-html/popper.min.js"></script>
<script src="systeme_suisse_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="systeme_suisse_files/libs/quarto-html/anchor.min.js"></script>
<link href="systeme_suisse_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="systeme_suisse_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="systeme_suisse_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="systeme_suisse_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="systeme_suisse_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Système suisse</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<section id="appariement-au-systeme-suisse-fonde-sur-lelo" class="level1">
<h1>APPARIEMENT AU SYSTEME SUISSE FONDE SUR L’ELO</h1>
<section id="a.-remarques-préliminaires-et-définitions" class="level2">
<h2 class="anchored" data-anchor-id="a.-remarques-préliminaires-et-définitions">A. Remarques préliminaires et définitions</h2>
<section id="a.1-elo" class="level3">
<h3 class="anchored" data-anchor-id="a.1-elo">A.1 Elo</h3>
<p>Il est conseillé de vérifier tous les classements Elo fournis par les joueurs. Si le joueur n’a pas de classement Elo, l’arbitre doit faire une estimation aussi précise que possible, avant le début du tournoi.</p>
</section>
<section id="a.2-classement-initial-et-numéros-dappariement" class="level3">
<h3 class="anchored" data-anchor-id="a.2-classement-initial-et-numéros-dappariement">A.2 Classement initial et numéros d’appariement</h3>
<p>Ordre de présentation des joueurs : Pour les appariements, les joueurs sont rangés d’après les critères suivants (par ordre décroissant) :</p>
<ol type="a">
<li>Score.</li>
<li>Classement Elo.</li>
<li>Grade</li>
<li>Ordre alphabétique, à moins que le règlement intérieur du tournoi n’ait prévu un autre critère à la place de celui-ci.</li>
</ol>
<p>Le classement fait avant la première ronde (alors qu’aucun point n’a été marqué) déterminera les numéros d’appariement, le plus grand Classement Elo étant le numéro 1.</p>
</section>
<section id="a.3-niveaux-de-points" class="level3">
<h3 class="anchored" data-anchor-id="a.3-niveaux-de-points">A.3 Niveaux de points</h3>
<p>Les joueurs ayant le même nombre de points constituent un niveau de points homogène. Les joueurs restant non appariés après l’appariement de leur niveau seront transférés dans le niveau immédiatement inférieur. Ce niveau deviendra alors un niveau de points hétérogène. Lorsqu’on apparie un niveau hétérogène, ces joueurs transférés vers le bas sont toujours appariés en priorité si cela est possible, les joueurs restants forment alors de nouveau un niveau homogène (que l’on appellera niveau résiduel). Un niveau de point hétérogène dans lequel la moitié des joueurs au moins provient des niveaux supérieurs, est également traité comme un niveau homogène.</p>
</section>
<section id="a.4-flotteurs" class="level3">
<h3 class="anchored" data-anchor-id="a.4-flotteurs">A.4 Flotteurs</h3>
<p>En appariant un niveau hétérogène, des joueurs de scores différents seront appariés ensemble. De tels joueurs sont appelés flotteurs. Pour éviter qu’un joueur ne flotte deux fois de suite, l’arbitre devra inscrire sur la fiche d’appariement une flèche (“basse”) pour le joueur ayant le score le plus élevé et une flèche (“haute”) pour le joueur ayant le score le plus faible.</p>
<p>Précisions :</p>
<ol type="a">
<li>Influence des forfaits sur les flotteurs : Un gain par forfait est assimilé à une exemption :</li>
</ol>
<ul>
<li>un joueur gagnant par forfait est considéré comme flotteur descendant.</li>
<li>un joueur perdant par forfait n’est pas flotteur du tout. ceci quel que soit le statut de flotteur au moment des appariements.</li>
</ul>
<ol start="2" type="a">
<li>Influence des ajournées sur les flotteurs : C’est le problème des appariements que l’on doit effectuer alors que des ajournées sont encore en cours. Les flotteurs ne sont pas modifiés à l’issue des parties ajournées.</li>
</ol>
</section>
<section id="a.5-exempts" class="level3">
<h3 class="anchored" data-anchor-id="a.5-exempts">A.5 Exempts</h3>
<p>Si le nombre de joueurs est impair (ou le devient), un joueur restera inapparié lorsque tous les niveaux auront été traités. Ce joueur sera alors exempté il n’aura ni adversaire, ni couleur. Il recevra 1 point. Il sera considéré comme un flotteur descendant.</p>
</section>
<section id="a.6-sous-groupes-lots-de-joueurs" class="level3">
<h3 class="anchored" data-anchor-id="a.6-sous-groupes-lots-de-joueurs">A.6 Sous-groupes (Lots de joueurs)</h3>
<p>Pour apparier, chaque niveau de points sera divisé en deux lots, appelés S1 et S2. Dans un niveau de points hétérogène, S1 contient tous les joueurs issus des niveaux supérieurs. Dans un niveau de points homogène, S1 contient la moitié des joueurs , ces joueurs étant les plus “forts” du niveau. Si le nombre de joueurs du niveau est impair, le nombre de joueurs de S1 est arrondi au nombre entier inférieur.</p>
<p>Le nombre de joueurs de S1 sera appelé p, indiquant également le nombre d’appariements à réaliser dans ce niveau de points. Dans les deux cas, S2 contiendra tous les autres joueurs du niveau de points.</p>
<p>Dans les lots S1 et S2, les joueurs seront ordonnés selon la règle A2.</p>
</section>
<section id="a.7-permutations-et-échanges" class="level3">
<h3 class="anchored" data-anchor-id="a.7-permutations-et-échanges">A.7 Permutations et échanges</h3>
<ol type="a">
<li><p>Pour parvenir à un appariement convenable, il est souvent nécessaire d’opérer des changements dans S2. De tels changements, appelés permutations, sont expliqués au paragraphe D1.</p></li>
<li><p>Dans un niveau de points homogène, il peut être nécessaire d’échanger des joueurs entre S1 et S2. Les règles d’échange sont expliquées au paragraphe D2. Après chaque échange, S1 et S2 seront réordonnés suivant la règle A2.</p></li>
</ol>
</section>
<section id="a.8-définition-de-x" class="level3">
<h3 class="anchored" data-anchor-id="a.8-définition-de-x">A.8 Définition de x</h3>
<p>x est le nombre de joueurs du niveau de points qui ne pourront pas être apparier dans ce niveau et devront rejoindre un niveau inférieur (flotteurs descendants).</p>
<p>x est initialisé à 0 si le nombre de joueurs du niveau est pair, à 1 s’il est impair.</p>
</section>
</section>
<section id="b.-critères-dappariement" class="level2">
<h2 class="anchored" data-anchor-id="b.-critères-dappariement">B. Critères d’appariement</h2>
<section id="critères-absolus" class="level3">
<h3 class="anchored" data-anchor-id="critères-absolus">Critères absolus</h3>
<p>(Ces critères sont inviolables. Si c’est nécessaire, les joueurs seront transférés dans un niveau de points inférieur.)</p>
<p>B1 :</p>
<p>a) Deux joueurs ne se rencontreront pas plus d’une seule fois.</p>
<p>b) Un joueur qui a reçu un point sans jouer, par exemption ou à cause de l’absence d’un adversaire, ne pourra plus être exempt.</p>
</section>
<section id="critères-relatifs-de-seconde-importance" class="level3">
<h3 class="anchored" data-anchor-id="critères-relatifs-de-seconde-importance">Critères relatifs (de seconde importance)</h3>
<p>Ils sont présentés dans l’ordre de priorité décroissante. Ils devront être respectés autant que possible, au besoin en effectuant des permutations dans S2 et même des échanges entre S1 et S2, mais aucun joueur ne pourra être transféré dans un niveau de point inférieur.</p>
<p>B3 : La différence de points entre deux joueurs appariés l’un contre l’autre sera la plus petite possible, l’idéal étant zéro.</p>
<p>B5 : Aucun joueur ne flottera deux fois de suite dans le même sens .</p>
<p>B6 : Un joueur ayant flotté à une ronde ne pourra être flotteur dans le même sens deux rondes plus tard.</p>
<p>NOTE : Les règles B5 et B6 ne seront pas appliqués lors de l’appariement de joueurs ayant un score de plus de 50 %, à la dernière ronde.</p>
</section>
</section>
<section id="c.-règles-dappariement" class="level2">
<h2 class="anchored" data-anchor-id="c.-règles-dappariement">C. Règles d’appariement</h2>
<p>Appliquer les règles suivantes à tous les niveaux de points, en commençant par le plus haut niveau, jusqu’à ce que l’on obtienne un appariement convenable.</p>
<p>C 1 : Si, dans un niveau de points, un joueur ne peut être apparié sans violer les critères B1 ou B2, alors :</p>
<ul>
<li>si ce joueur venait d’un niveau supérieur, appliquer la règle C12.</li>
<li>si l’on est en train d’apparier le dernier niveau, appliquer la règle C13.</li>
<li>dans tous les autres cas, faire flotter le joueur posant problème dans le niveau inférieur le plus proche.</li>
</ul>
<p>C 2 : Calculer x suivant la règle A 8.</p>
<p>C 3 : Calculer p suivant la règle A 6.</p>
<p>C 4 : Placer les p joueurs les plus forts en S1, et tous les autres joueurs en S2.</p>
<p>C 5 : Ordonner les joueurs de S1 et S2 suivant A2.</p>
<p>C 6 : Apparier le joueur le plus fort de S1 contre le joueur le plus fort de S2, et ainsi de suite. Si les appariements sont réalisés en respectant B1 et B2, l’appariement de ce niveau est provisoirement terminé.</p>
<ul>
<li><p>Dans le cas d’un niveau de points homogène: les joueurs restants flottent vers le niveau immédiatement inférieur pour lequel on recommence en C1.</p></li>
<li><p>Dans le cas d’un niveau de points hétérogène, seuls les flotteurs sont appariés pour l’instant. Recommencer en C2 avec les joueurs restants qui forment maintenant un niveau homogène (niveau résiduel).</p></li>
</ul>
<p>C 7 : Procéder à une nouvelle permutation dans S2 suivant la règle D1 et recommencer en C6.</p>
<p>C 8 : Dans le cas d’un niveau homogène (ou niveau résiduel), faire un nouvel échange entre S1 et S2 suivant D2 et recommencer en C5.</p>
<p>C 9 : Abandonner les critères B6 puis B5 pour les flotteurs descendants et reprendre en C4.</p>
<p>C 10 : Dans le cas d’un niveau homogène résiduel, défaire l’appariement du plus petit flotteur descendant et essayer de lui trouver un adversaire différent, en reprenant en C7. S’il n’y a pas d’autre alternative pour ce joueur, abandonner le critère B6 puis B5 pour les flotteurs montants et recommencer en C2.</p>
<p>C 11 : Tant que x &lt; p, augmenter x de 1. Quand on apparie un groupe résiduel, défaire tous les appariements des joueurs, y compris ceux des flotteurs descendants. Recommencer en C3.</p>
<p>C 12 : Dans le cas d’un niveau de points hétérogène, défaire l’appariement du précédent niveau. Si dans ce niveau de point précédent, un appariement peut être fait dans lequel un autre joueur sera flotteur descendant et que cela permet p appariements dans le niveau en cours, alors ce nouvel appariement dans le niveau de point précédent sera conservé.</p>
<p>C13 : Dans le cas du niveau de point le plus bas, l’appariement de l’avant dernier niveau est annulé, essayer de trouver un autre appariement dans cet avant dernier niveau de points, qui permettra l’appariement du dernier niveau de points. Si, dans l’avant dernier niveau de points, p devient égal à zéro (c’est à dire qu’aucun appariement n’est possible pour que l’appariement du dernier niveau de points soit réalisable), alors les deux niveaux les plus bas seront regroupés en un seul. Étant donné que c’est maintenant un autre niveau qui devient l’avant-dernier, C13 peut être répété jusqu’à obtenir un appariement réalisable.</p>
<p>C 14 : Diminuer p de 1 (si la valeur première de x était 1, passer aussi x à 0). Tant que p n’est pas égal à 0, recommencer en C4. Si p = 0, tout le niveau de points est descendu au niveau suivant. Recommencer la procédure avec ce niveau en C1.</p>
</section>
<section id="d.-règles-de-permutation-et-déchange" class="level2">
<h2 class="anchored" data-anchor-id="d.-règles-de-permutation-et-déchange">D. Règles de permutation et d’échange</h2>
<p><em>Exemple :</em> S1 contient les joueurs 1, 2, 3 et 4 ; S2 contient les joueurs 5, 6, 7 et 8</p>
<p>D1 : Les permutations dans S2 commenceront avec le joueur le plus “faible” (plus grand numéro) dans l’ordre des priorités décroissantes suivantes : a) 5-6-8-7; b) 5-7-6-8; c) 5-7-8-6; d) 5-8-6-7; e) 5-8-7-6; f) 6-5-7-8 g) 6-5-8-7 etc.</p>
<p>Note : Cela revient à écrire tous les nombres possibles avec 5, 6, 7 et 8 dans l’ordre croissant.</p>
<p>D2 : Quand on procède à un échange entre S1 et S2, la différence entre les numéros échangés doit être la plus petite possible. Lorsque les différents choix proposés donnent la même différence, prendre celui qui concerne le joueur le plus “faible” possible de S1.</p>
<p>Echanger un joueur :</p>
<table class="table">
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"><strong>S1</strong></th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">2</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">a</td>
<td style="text-align: center;">c</td>
<td style="text-align: center;">f</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>S2</strong></td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">b</td>
<td style="text-align: center;">e</td>
<td style="text-align: center;">h</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">7</td>
<td style="text-align: center;">d</td>
<td style="text-align: center;">g</td>
<td style="text-align: center;">i</td>
</tr>
</tbody>
</table>
<p>Echanger deux joueurs :</p>
<table class="table">
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"></th>
<th style="text-align: center;"><strong>S1</strong></th>
<th style="text-align: center;"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">3+4</td>
<td style="text-align: center;">2+4</td>
<td style="text-align: center;">2+3</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">5+6</td>
<td style="text-align: center;">j</td>
<td style="text-align: center;">l</td>
<td style="text-align: center;">o</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>S2</strong></td>
<td style="text-align: center;">5+7</td>
<td style="text-align: center;">k</td>
<td style="text-align: center;">n</td>
<td style="text-align: center;">q</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">6+7</td>
<td style="text-align: center;">m</td>
<td style="text-align: center;">p</td>
<td style="text-align: center;">r</td>
</tr>
</tbody>
</table>
<p>Les tableaux ci-dessus montrent comment faire les échanges. Après chaque échange, S1 et S2 doivent être reclassés suivant la règle A2.</p>
<p>Remarque : Si le nombre de joueurs dans un niveau de points est impair, S1 a un joueur de moins que S2. Avec 7 joueurs, S1 : 1, 2, 3 et S2 : 4, 5, 6, 7. Les échanges dans ce cas peuvent se déduire des précédents en réduisant de 1 tous les nombres de S1 et de S2.</p>
</section>
<section id="e.-remarques-finales" class="level2">
<h2 class="anchored" data-anchor-id="e.-remarques-finales">E. Remarques finales</h2>
<p>E1 . A l’issue de l’appariement, classer les matchs avant de les publier. Le critère de classement est, en priorité :</p>
<ul>
<li>le score du plus “fort” joueur.</li>
<li>la somme des scores des deux joueurs du match concerné.</li>
<li>le classement suivant A2 du plus “fort” joueur du match concerné.</li>
</ul>
<p>E2 . Une exemption, ou l’absence d’un joueur (forfait) ne rendront pas illégal un nouvel appariement entre les deux joueurs pour les rondes suivantes.</p>
<p>E4 . Comme tous les joueurs sont dans un niveau de points homogène avant le début de la première ronde et sont classés suivant A2, le premier joueur de S1 jouera contre le premier joueur de S2. Si le nombre est impair, le dernier joueur de S2 sera exempt.</p>
<p>E5 . Les joueurs qui se retirent ne sont plus appariés. Les joueurs dont on sait qu’ils ne participeront pas à une ronde particulière ne seront pas appariés pour cette ronde et marqueront 0 point.</p>
<p>E6 . Un appariement officiellement publié ne sera pas changé, à moins qu’il ne respecte pas les règles impératives B1 ou B2.</p>
<p>E7 . Si l’un des cas suivants se produit:</p>
<ul>
<li>un résultat n’a pas été enregistré correctement</li>
<li>un Elo doit être corrigé</li>
</ul>
<p>alors la correction n’affectera que les appariements encore à faire Si toutefois, cela affectait un appariement déjà publié mais pas encore joué, la décision serait prise par l’arbitre.</p>
<p><em>A moins que le règlement du tournoi n’en dispose autrement :</em></p>
<p>E8 . Les joueurs absents lors d’une ronde, sans avoir prévenu l’arbitre, seront considérés comme ayant abandonné et ne seront donc plus appariés.</p>
<p>E9 . Les parties ajournées sont considérées comme nulles, pour les besoins de l’appariement seulement.</p>
<p>E10 . Pour dresser le classement final, les critères suivants seront appliqués</p>
<ul>
<li>le plus grand score. Si plusieurs joueurs ont ce même score, les prix seront partagés.</li>
<li>en ce qui concerne la première place, le départage se fera d’après les résultats des matchs entre les joueurs ex aequo.</li>
<li>la plus grande moyenne des Elo des adversaires</li>
<li>le tirage au sort.</li>
</ul>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>